#include "it-module.h"

static uint8_t IT_MODULE[] = {
	0x49, 0x4D, 0x50, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10,
	0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x30, 0x51, 0x14, 0x02, 0x49, 0x00, 0x06, 0x00,
	0x80, 0x30, 0x06, 0x7D, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
	0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0xFF, 0xD4, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x01, 0x00, 0xBB, 0x54, 0x4D, 0x73,
	0x0D, 0x13, 0x00, 0x00, 0x49, 0x4D, 0x50, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x11, 0x40, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
	0xAB, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x03, 0x3C, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const size_t IT_MODULE_SIZE = sizeof(IT_MODULE);

constexpr std::size_t BUFFER_SIZE = 2048;
constexpr std::int32_t SAMPLE_RATE = 48000;

IT_Module::IT_Module(const Song &song) : _left(BUFFER_SIZE), _right(BUFFER_SIZE), _interleaved_buffer(BUFFER_SIZE * 2) {
	// TODO: generate data from song
	_size = IT_MODULE_SIZE;
	_data = new uint8_t[_size];
	for (size_t i = 0; i < _size; ++i) {
		_data[i] = IT_MODULE[i];
	}

	_mod = new openmpt::module(_data, _size);

	_is_interleaved = false;
	if (!try_open()) {
		_is_interleaved = true;
		try_open();
	}
}

IT_Module::~IT_Module() noexcept {
	if (_data) {
		delete [] _data;
		_data = nullptr;
	}
	if (_mod) {
		delete _mod;
		_mod = nullptr;
	}
}

void IT_Module::play() {
	if (!ready() || !is_playing()) return;

	std::size_t count = _is_interleaved ?
		_mod->read_interleaved_stereo(SAMPLE_RATE, BUFFER_SIZE, _interleaved_buffer.data()) :
		_mod->read(SAMPLE_RATE, BUFFER_SIZE, _left.data(), _right.data());

	if (count == 0) {
		stop();
		return;
	}
	try {
		if (_is_interleaved) {
			_stream.write(_interleaved_buffer.data(), static_cast<unsigned long>(count));
		}
		else {
			const float * const buffers[2] = { _left.data(), _right.data() };
			_stream.write(buffers, static_cast<unsigned long>(count));
		}
	}
	catch (...) {}
}

bool IT_Module::try_open() {
	try {
		portaudio::System &portaudio = portaudio::System::instance();
		portaudio::DirectionSpecificStreamParameters outputstream_parameters(
			portaudio.defaultOutputDevice(),
			2,
			portaudio::FLOAT32,
			_is_interleaved,
			portaudio.defaultOutputDevice().defaultHighOutputLatency(),
			0
		);
		portaudio::StreamParameters stream_parameters(
			portaudio::DirectionSpecificStreamParameters::null(),
			outputstream_parameters,
			SAMPLE_RATE,
			paFramesPerBufferUnspecified,
			paNoFlag
		);
		_stream.open(stream_parameters);
		return true;
	}
	catch (...) {}
	return false;
}
